elixir types can hold values of any type(including other collections)

Tuples
=======
A tuple is an ordered collection of values.
As will all elixir data structures , once created a tuple cannot be modified
you write a tuple between braces, separating the elements with commas

--code-------
 { 1,2 }
 --end code---

a typical elixir tuple had two to four elements - any more and you will probably want to look at maps or structs

you can use tuples in pattern matching

----code-------
iex(5)> {status, count, action } = {:ok,43,"next"}
{:ok, 43, "next"}
iex(6)> 
---end code----------

“t is common for functions to return a tuple where the first element
is the atom :ok if there were no errors.”

“​iex>​ {status, file} = File.open(​"​​mix.exs"​)​ 
{:ok, #PID<0.39.0>}”

“Because the file was successfully opened, the tuple contains an :ok
status and a PID, which is how we access the contents.”

Lists
========
a list is a linked data structures.
Lists in Elixir are specified between square brackets:

[1, "two", 3, :four]
[1, "two", 3, :four]

a list may either be empty or consist of a head and a tail.
the head contains a value and the tail is itself a list.

because we often need simple list of key/value pairs, Elixir gives us a shortcut.
if we write 

[ name: "Dave", city: "Dallas", likes: "Programming" ]

elixir converts it into a list of two-value Tuples

[ {:name, "Dave"}, {:city, "Dallas"}, {:likes, "Programming"} ]

Two lists can be concatenated and subtracted using the ++/2 and --/2 operators:

[1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]

An element can be prepended to a list using |:

new = 0
list = [1, 2, 3]
[new | list]
[0, 1, 2, 3]

prepending an element to a list is always fast (constant time), 
while appending becomes slower as the list grows in size (linear time):

list = [1, 2, 3]
[0 | list] # fast
[0, 1, 2, 3]
list ++ [4] # slow
[1, 2, 3, 4]

functions of list 

iex(28)> list = [1,2,3,4,5] 
[1, 2, 3, 4, 5]
iex(29)> hd(list)  # returns head of a list
1
iex(30)> tl(list)  # returns tail of a list
[2, 3, 4, 5]
iex(31)> length(list) # returns length of a list
5
 